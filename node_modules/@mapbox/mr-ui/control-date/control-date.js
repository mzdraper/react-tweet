'use strict';

exports.__esModule = true;

var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _controlLabel = require('../control-label');

var _controlLabel2 = _interopRequireDefault(_controlLabel);

var _controlWrapper = require('../control-wrapper');

var _controlWrapper2 = _interopRequireDefault(_controlWrapper);

var _reactDatepicker = require('react-datepicker');

var _reactDatepicker2 = _interopRequireDefault(_reactDatepicker);

var _getWindow = require('../utils/get-window');

var _getWindow2 = _interopRequireDefault(_getWindow);

var _datePickerStyle = require('./date-picker-style');

var _datePickerStyle2 = _interopRequireDefault(_datePickerStyle);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Theme cache, used to prevent the creation of multiple <style> elements with the same content.
var injectedStyles = [];

var ControlDate = function (_React$Component) {
  (0, _inherits3.default)(ControlDate, _React$Component);

  function ControlDate(props) {
    (0, _classCallCheck3.default)(this, ControlDate);

    var _this = (0, _possibleConstructorReturn3.default)(this, _React$Component.call(this, props));

    _initialiseProps.call(_this);

    var value = props.value;
    _this.moment = props.moment;
    _this.state = {
      momentDate: value && value.date ? _this.moment(value.date) : null,
      momentEndDate: value && value.endDate ? _this.moment(value.endDate) : null
    };
    return _this;
  }

  ControlDate.prototype.componentDidMount = function componentDidMount() {
    // Do not load themes that have already been injected.
    if (injectedStyles.indexOf(_datePickerStyle2.default) !== -1) {
      return;
    }
    injectedStyles.push(_datePickerStyle2.default);
    var doc = (0, _getWindow2.default)().document;
    this.styleTag = doc.createElement('style');
    this.styleTag.innerHTML = _datePickerStyle2.default;
    doc.head.appendChild(this.styleTag);
  };

  ControlDate.prototype.render = function render() {
    var _props = this.props,
        dateRange = _props.dateRange,
        maxDate = _props.maxDate,
        minDate = _props.minDate,
        id = _props.id,
        disabled = _props.disabled,
        format = _props.format,
        utcOffset = _props.utcOffset,
        label = _props.label,
        aside = _props.aside,
        placeholder = _props.placeholder,
        endDatePlaceholder = _props.endDatePlaceholder,
        themeLabel = _props.themeLabel,
        themeWrapper = _props.themeWrapper,
        themeCalendar = _props.themeCalendar,
        themeTextInput = _props.themeTextInput,
        validationError = _props.validationError;

    var sharedDatePickerProps = {
      className: themeTextInput,
      startDate: this.state.momentDate,
      endDate: this.state.momentEndDate,
      minDate: minDate ? this.props.moment(minDate) : undefined,
      maxDate: maxDate ? this.props.moment(maxDate) : undefined,
      calendarClassName: themeCalendar,
      dateFormat: format,
      disabledKeyboardNavigation: true,
      popperModifiers: {
        preventOverflow: {
          enabled: true,
          escapeWithReference: true,
          boundariesElement: 'viewport'
        }
      },
      utcOffset: utcOffset,
      disabled: disabled
    };
    var sharedNativeDateProps = {
      className: 'input input-s w180 block none-mm',
      pattern: '[0-9]{4}-[0-9]{2}-[0-9]{2}',
      type: 'date',
      min: minDate ? this.props.moment(minDate).format('YYYY-MM-DD') : undefined,
      max: maxDate ? this.props.moment(maxDate).format('YYYY-MM-DD') : undefined,
      disabled: disabled
    };

    var controlLabel = label && _react2.default.createElement(_controlLabel2.default, {
      text: label,
      id: id,
      aside: aside,
      themeLabel: themeLabel
    });
    var basePicker = _react2.default.createElement(
      'div',
      { className: 'flex-parent' },
      _react2.default.createElement(_reactDatepicker2.default, (0, _extends3.default)({}, sharedDatePickerProps, {
        selected: this.state.momentDate,
        onChange: this.changeStartDate,
        onChangeRaw: this.onChangeRawStartDate,
        placeholderText: placeholder,
        id: id
      })),
      _react2.default.createElement('input', (0, _extends3.default)({}, sharedNativeDateProps, {
        value: this.state.momentDate ? this.state.momentDate.format('YYYY-MM-DD') : '',
        placeholder: placeholder,
        onChange: this.nativeChangeDate
      }))
    );
    var endDatePicker = this.state.momentEndDate || dateRange ? _react2.default.createElement(
      'div',
      { className: 'flex-parent' },
      _react2.default.createElement(_reactDatepicker2.default, (0, _extends3.default)({}, sharedDatePickerProps, {
        selected: this.state.momentEndDate,
        onChange: this.changeEndDate,
        onChangeRaw: this.onChangeRawEndDate,
        placeholderText: endDatePlaceholder
      })),
      _react2.default.createElement('input', (0, _extends3.default)({}, sharedNativeDateProps, {
        value: this.state.momentEndDate ? this.state.momentEndDate.format('YYYY-MM-DD') : '',
        placeholder: endDatePlaceholder,
        onChange: this.nativeChangeEndDate
      }))
    ) : null;
    var doubleButtonDivider = this.state.momentEndDate || dateRange ? _react2.default.createElement(
      'span',
      { className: 'px12' },
      'to'
    ) : null;

    return _react2.default.createElement(
      _controlWrapper2.default,
      { id: id, validationError: validationError },
      _react2.default.createElement(
        'div',
        null,
        controlLabel,
        _react2.default.createElement(
          'div',
          { className: themeWrapper },
          basePicker,
          doubleButtonDivider,
          endDatePicker
        )
      )
    );
  };

  return ControlDate;
}(_react2.default.Component);

ControlDate.propTypes = {
  /** Your version of Moment.js. What you get when you `import moment from 'moment'`. */
  moment: _propTypes2.default.func.isRequired,
  /** Unique id for this control. Required if you want a `label`. */
  id: _propTypes2.default.string,
  /**
   * The control's value. Can be an empty string to indicate no value.
   * Otherwise, should be an object with a required `date` property and
   * optional `endDate`. If `endDate` is provided, `date` serves as the
   * start date for the range.
   */
  value: _propTypes2.default.oneOfType([_propTypes2.default.shape({
    date: _propTypes2.default.instanceOf(Date).isRequired,
    endDate: _propTypes2.default.instanceOf(Date)
  }), _propTypes2.default.oneOf([''])]),
  /**
   * If `true`, there will be one input for the start of a date range
   * and one input for the end of a date range. If `false`, there will only
   * be one input for a single date.
   */
  dateRange: _propTypes2.default.bool,
  /** Date furthest in the future you can select. */
  maxDate: _propTypes2.default.instanceOf(Date),
  /** Date furthest in the past you can select. */
  minDate: _propTypes2.default.instanceOf(Date),
  /** If `true`, the control cannot be interacted with. */
  disabled: _propTypes2.default.bool,
  /**
   * Placeholder for the inputs.
   * If `dateRange` is true, this placeholder applies to both
   * inputs unless you provide an `endDatePlaceholder`.
   */
  placeholder: _propTypes2.default.string,
  /**
   * Placeholder for the end date input, if `dateRange` is true.
   * If nothing is provided, the end date input will show the `placeholder`.
   */
  endDatePlaceholder: _propTypes2.default.string,
  /**
   * [Moment.js format](http://momentjs.com/docs/#/displaying/format/)
   * the inputs will display and accept (e.g. `'YYYY MM DD'`).
   */
  format: _propTypes2.default.string,
  /** Force a certain UTC offset, useful mostly for stabilizing tests. */
  utcOffset: _propTypes2.default.number,
  /** Label for the control. */
  label: _propTypes2.default.string,
  /** Additional content inserted alongside the label element. */
  aside: _propTypes2.default.node,
  /** Classes to apply to the label element. */
  themeLabel: _propTypes2.default.string,
  /**
   * Invoked when the control's value changes.
   * Passed two arguments:
   *
   * - The date value. An object with a `date` and, if the control allows
   *   a date range, an `endDate`.
   * - The `id` prop.
   */
  onChange: _propTypes2.default.func.isRequired,
  /** Classes to apply to the control wrapper. */
  themeWrapper: _propTypes2.default.string,
  /** Classes to apply to the datepicker's calendar. */
  themeCalendar: _propTypes2.default.string,
  /** Classes to apply to the input elements. */
  themeTextInput: _propTypes2.default.string,
  /** A validation error to display beneath the control. */
  validationError: _propTypes2.default.node
};
ControlDate.defaultProps = {
  dateRange: false,
  placeholder: 'M/D/YYYY',
  endDatePlaceholder: 'M/D/YYYY',
  format: 'M/D/YYYY',
  themeWrapper: 'react-control-date react-control-date--disable-keyboard flex-parent-inline flex-parent--center-cross flex-parent--wrap',
  themeCalendar: 'shadow-darken10 border--0 none block-mm',
  themeTextInput: 'input w180 none block-mm'
};

var _initialiseProps = function _initialiseProps() {
  var _this2 = this;

  this.getDateData = function () {
    return _this2.state.momentEndDate ? {
      date: _this2.state.momentDate ? _this2.state.momentDate.toDate() : null,
      endDate: _this2.state.momentEndDate ? _this2.state.momentEndDate.toDate() : null
    } : {
      date: _this2.state.momentDate ? _this2.state.momentDate.toDate() : null
    };
  };

  this.handleChange = function (date, changedDateKey) {
    var _this2$setState;

    // date: moment
    var _props2 = _this2.props,
        minDate = _props2.minDate,
        maxDate = _props2.maxDate,
        moment = _props2.moment;

    if (date === null) return;
    if (minDate && date.isBefore(moment(minDate))) return;
    if (maxDate && date.isAfter(moment(maxDate))) return;
    _this2.setState((_this2$setState = {}, _this2$setState[changedDateKey] = date, _this2$setState), function () {
      _this2.props.onChange(_this2.getDateData(), _this2.props.id);
    });
  };

  this.changeStartDate = function (date) {
    return _this2.handleChange(date, 'momentDate');
  };

  this.changeEndDate = function (date) {
    return _this2.handleChange(date, 'momentEndDate');
  };

  this.nativeChangeDate = function (e) {
    return _this2.handleChange(_this2.moment(e.target.value, 'YYYY-MM-DD'), 'momentDate');
  };

  this.nativeChangeEndDate = function (e) {
    return _this2.handleChange(_this2.moment(e.target.value, 'YYYY-MM-DD'), 'momentEndDate');
  };

  this.handleChangeRaw = function (value, changedDateKey) {
    // clears set date
    var momentifiedDate = _this2.moment(value, _this2.props.format, true);
    if (!momentifiedDate.isValid()) {
      var _this2$setState2;

      _this2.setState((_this2$setState2 = {}, _this2$setState2[changedDateKey] = null, _this2$setState2), function () {
        _this2.props.onChange(_this2.getDateData(), _this2.props.id);
      });
    }
  };

  this.onChangeRawStartDate = function (e) {
    return _this2.handleChangeRaw(e.target.value, 'momentDate');
  };

  this.onChangeRawEndDate = function (e) {
    return _this2.handleChangeRaw(e.target.value, 'momentEndDate');
  };
};

exports.default = ControlDate;