'use strict';

exports.__esModule = true;

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _classnames = require('classnames');

var _classnames2 = _interopRequireDefault(_classnames);

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _button = require('../button');

var _button2 = _interopRequireDefault(_button);

var _popoverTrigger = require('../popover-trigger');

var _popoverTrigger2 = _interopRequireDefault(_popoverTrigger);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var tooltipCounter = 0;

/**
 * Wrap a trigger element so that when it is hovered or focused a tooltip
 * appears.
 *
 * Tooltip extends [PopoverTrigger](#popovertrigger) and configures the
 * popover and trigger for accessibility.
 */

var Tooltip = function (_React$Component) {
  (0, _inherits3.default)(Tooltip, _React$Component);

  function Tooltip() {
    var _temp, _this, _ret;

    (0, _classCallCheck3.default)(this, Tooltip);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = (0, _possibleConstructorReturn3.default)(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.state = {
      visible: false,
      tooltipId: null
    }, _temp), (0, _possibleConstructorReturn3.default)(_this, _ret);
  }

  Tooltip.prototype.componentDidMount = function componentDidMount() {
    // Save the application for the random generated id until after mount
    // so that it doesn't mess up the relation of static/dynamic React code.
    // Generating unique ids for server-rendered code without breaking
    // the checksum is very hard!
    tooltipCounter += 1;
    this.setState({ tooltipId: 'tooltip-' + tooltipCounter });
  };

  Tooltip.prototype.getContent = function getContent() {
    var content = this.props.content;

    if (typeof content === 'function') {
      return content();
    } else {
      return content;
    }
  };

  Tooltip.prototype.renderTrigger = function renderTrigger() {
    var _props = this.props,
        children = _props.children,
        testId = _props.testId;
    var tooltipId = this.state.tooltipId;


    if (!children) {
      return null;
    }

    var triggerProps = { 'aria-describedby': tooltipId };
    if (testId) {
      triggerProps['data-test'] = testId + '-trigger';
    }

    if (typeof children === 'function') {
      return children(triggerProps);
    }
    if (children.type && typeof children.type === 'string') {
      return _react2.default.cloneElement(children, triggerProps);
    }
    if (children.type && children.type === _button2.default) {
      return _react2.default.cloneElement(children, { passthroughProps: triggerProps });
    }
    throw new Error('Tooltip requires a child that is a function, a regular DOM node, or a Button. If your trigger is a different custom component, pass a function as the child.');
  };

  Tooltip.prototype.render = function render() {
    var props = this.props,
        state = this.state;


    var popoverPassthroughProps = {
      id: state.tooltipId,
      // Override the "dialog" role set by popover
      role: 'tooltip'
    };

    if (props.testId) {
      popoverPassthroughProps['data-test'] = props.testId + '-tooltip';
    }

    var bodyClasses = (0, _classnames2.default)({
      'txt-s': props.textSize === 's',
      'txt-xs': props.textSize === 'xs',
      wmax120: props.maxWidth === 'small',
      wmax240: props.maxWidth === 'medium'
    });

    var content = _react2.default.createElement(
      'div',
      { className: bodyClasses },
      this.getContent()
    );

    return _react2.default.createElement(
      _popoverTrigger2.default,
      {
        content: content,
        renderHiddenContent: true,
        disabled: props.disabled,
        block: props.block,
        respondsToClick: props.respondsToClick,
        respondsToHover: true,
        respondsToFocus: true,
        receiveFocus: false,
        popoverProps: {
          hasPointer: true,
          placement: props.placement,
          alignment: props.alignment,
          coloring: props.coloring,
          padding: props.padding,
          hideWhenAnchorIsOffscreen: true,
          passthroughProps: popoverPassthroughProps
        }
      },
      this.renderTrigger()
    );
  };

  return Tooltip;
}(_react2.default.Component);

exports.default = Tooltip;


Tooltip.propTypes = {
  /**
   * The trigger element.
   *
   * If your element is a DOM element
   * (e.g. `<button>`, `<a>`, `<span>`, `<div>`),
   * you can pass it directly and it will have accessibility-related props
   * automatically added to it.
   *
   * If your element is a custom React component, you need to provide a
   * function as the child. The function will be invoked with a `triggerProps`
   * object, and you need to apply those `triggerProps` in such a way that
   * they end up on the DOM element of the trigger.
   */
  children: _propTypes2.default.oneOfType([_propTypes2.default.func, _propTypes2.default.node]).isRequired,
  /**
   * The tooltip content. This can either be a string, valid JSX, or a function
   * returning either.
   */
  content: _propTypes2.default.oneOfType([_propTypes2.default.func, _propTypes2.default.node]).isRequired,
  /**
   * Placement of the tooltip in relation to the trigger element.
   */
  placement: _propTypes2.default.oneOf(['top', 'bottom', 'left', 'right']),
  /**
   * Alignment of the tooltip's edge in relation to the trigger element.
   */
  alignment: _propTypes2.default.oneOf(['top', 'bottom', 'left', 'right', 'center']),
  /**
   * If `true`, the tooltip will not appear.
   */
  disabled: _propTypes2.default.bool,
  /**
   * `'light'`, `'dark'`, or `'warning'`.
   */
  coloring: _propTypes2.default.oneOf(['light', 'dark', 'warning']),
  /**
   * `'xs'` (extra small), `'s'` (small), or `'none'` (no size class).
   */
  textSize: _propTypes2.default.oneOf(['xs', 's', 'none']),
  /**
   * `'small'`, `'medium'`, or `'none'` (no `wmax*` class).
   */
  maxWidth: _propTypes2.default.oneOf(['small', 'medium', 'none']),
  /**
   * `'small'` or `'none'`.
   */
  padding: _propTypes2.default.oneOf(['small', 'none']),
  /**
   * If `true`, tooltip can be opened with a mouse click.
   */
  respondsToClick: _propTypes2.default.bool,
  /**
   * If `true`, the element will be `block` displayed instead of `inline-block`.
   *
   * This is sometimes necessary to get your pixel-perfect layout, if you don't
   * want the extra line-height that wraps inline elements. Typically, you
   * should only set `block` to `true` if the parent element is controlling
   * width (in a layout that uses flexbox, absolute positioning, or floats).
   */
  block: _propTypes2.default.bool,
  /**
   * Added as `data-test` to the tooltip element.
   */
  testId: _propTypes2.default.string
};

Tooltip.defaultProps = {
  placement: 'top',
  alignment: 'center',
  coloring: 'light',
  disabled: false,
  respondsToClick: false,
  padding: 'small',
  block: false,
  textSize: 's',
  maxWidth: 'medium'
};