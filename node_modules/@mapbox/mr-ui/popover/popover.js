'use strict';

exports.__esModule = true;

var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _classnames = require('classnames');

var _classnames2 = _interopRequireDefault(_classnames);

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _focusTrap = require('focus-trap');

var _focusTrap2 = _interopRequireDefault(_focusTrap);

var _tabbable = require('tabbable');

var _tabbable2 = _interopRequireDefault(_tabbable);

var _isElementScrolledIntoView = require('./is-element-scrolled-into-view');

var _isElementScrolledIntoView2 = _interopRequireDefault(_isElementScrolledIntoView);

var _popoverPositioner = require('./popover-positioner');

var _popoverPositioner2 = _interopRequireDefault(_popoverPositioner);

var _querySelectorContainsNode = require('@mapbox/query-selector-contains-node');

var _querySelectorContainsNode2 = _interopRequireDefault(_querySelectorContainsNode);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var popoverCounter = 0; // Incremented on creation

/**
 * Display a popover. The popover is positioned relative to an anchor element,
 * and the preferred position determined by props is adjusted according to the
 * available space.
 *
 * **Usually you won't need to use this low-level component.** You should have
 * a look at [Tooltip](#tooltip) and [PopoverTrigger](#popovertrigger).
 *
 * If you are using this component directly, you need to manage its open-closed
 * state. Use `onExit` to do that.
 *
 * The static function `Popover.repositionPopovers()` can be used to
 * automatically reposition *all the popovers that are currently open*. This is
 * useful if some state change other than a scroll or resize may have caused
 * the popover's anchor to move or the space available to the
 * popover to change.
 */

var Popover = function (_React$Component) {
  (0, _inherits3.default)(Popover, _React$Component);

  function Popover(props) {
    (0, _classCallCheck3.default)(this, Popover);

    var _this = (0, _possibleConstructorReturn3.default)(this, _React$Component.call(this, props));

    _initialiseProps.call(_this);

    popoverCounter += 1;
    _this.popoverId = popoverCounter;
    return _this;
  }

  Popover.prototype.componentWillMount = function componentWillMount() {
    // For focus management: focus will return to this element
    // when the popover is closed
    this.previouslyFocusedElement = document.activeElement;
  };

  Popover.prototype.componentDidMount = function componentDidMount() {
    var _this2 = this;

    this.hackListenerRemovers = [];
    if ('ontouchstart' in document.documentElement) {
      // Prevent a full-screen flash when there's a click.
      document.documentElement.style.WebkitTapHighlightColor = 'transparent';
      var bodyChildren = document.body.childNodes;

      var _loop = function _loop(i, l) {
        var node = bodyChildren[i];
        // Hack to fix click event bubbling in iOS
        // cf. https://www.quirksmode.org/blog/archives/2014/02/mouse_event_bub.html
        // Without this, a tap in iOS outside the popover will not close it.
        node.addEventListener('mouseover', noop);
        _this2.hackListenerRemovers.push(function () {
          node.removeEventListener('mouseover', noop);
        });
      };

      for (var i = 0, l = bodyChildren.length; i < l; i++) {
        _loop(i, l);
      }
    }
    // Listen for mousedown rather than click in the case that the Popover
    // trigger is an input. This ensures that onDocumentMousedown is called
    // first and does not unintentionally remove focus from the popover.
    document.addEventListener('mousedown', this.onDocumentMousedown);
    // Delay this focus because of
    // https://github.com/mapbox/www2.mapbox.com/issues/283
    // If you go from one popover to another, we need focus to
    // hit the first popover's trigger and *then* enter this popover's body
    this.focusBodyTimer = setTimeout(function () {
      _this2.maybeFocusPopover();
    }, 10);
  };

  Popover.prototype.componentDidUpdate = function componentDidUpdate() {
    // This is necessary if, for example, you've hovered over
    // a PopoverTrigger and *then* clicked it: it's already mounted
    // but only *now* should receive focus. Logic within maybeFocusPopover
    // will prevent us from re-focusing if we've already focused.
    this.maybeFocusPopover();
  };

  Popover.prototype.componentWillUnmount = function componentWillUnmount() {
    this.hackListenerRemovers.forEach(function (r) {
      return r();
    });
    document.removeEventListener('mousedown', this.onDocumentMousedown);
    if (this.focusBodyTimer) clearTimeout(this.focusBodyTimer);

    if (this.focusTrap) {
      this.focusTrap.deactivate();
      var previouslyFocusedElement = this.previouslyFocusedElement;
      // We must defer this call in order for a parent popover's
      // onBodyFocus method to pick up on the programmatic focus
      // https://github.com/facebook/react/issues/7835

      setTimeout(function () {
        // Only focus if it's visible, to avoid semi-mysterious scroll bouncing
        if (previouslyFocusedElement && (0, _isElementScrolledIntoView2.default)(previouslyFocusedElement)) {
          previouslyFocusedElement.focus();
        }
      }, 0);
    }
  };

  Popover.prototype.render = function render() {
    var props = this.props;

    var colors = getColors(props.coloring);
    var bodyClasses = (0, _classnames2.default)(colors.textClass + ' shadow-darken25 round', {
      'px12 py12': props.padding === 'medium',
      'px12 py6': props.padding === 'small'
    });

    return _react2.default.createElement(
      _popoverPositioner2.default,
      {
        getAnchorElement: props.getAnchorElement,
        hasPointer: props.hasPointer,
        placement: props.placement,
        alignment: props.alignment,
        pointerColor: colors.background,
        hideWhenAnchorIsOffscreen: props.hideWhenAnchorIsOffscreen,
        allowPlacementAxisChange: props.allowPlacementAxisChange,
        containWithinViewport: props.containWithinViewport,
        getContainingElement: props.getContainingElement,
        offsetFromAnchor: props.offsetFromAnchor,
        onElement: this.setPopoverElement
      },
      _react2.default.createElement(
        'div',
        (0, _extends3.default)({
          key: 'body',
          style: { backgroundColor: colors.background },
          className: bodyClasses,
          onKeyDown: this.onBodyKeyDown,
          onFocus: this.onBodyFocus,
          'data-popover-id': this.popoverId,
          tabIndex: -1,
          role: 'dialog'
        }, props.passthroughProps),
        props.children
      )
    );
  };

  return Popover;
}(_react2.default.Component);

var _initialiseProps = function _initialiseProps() {
  var _this3 = this;

  this.maybeFocusPopover = function () {
    if (!_this3.bodyElement) return;
    var props = _this3.props;


    if (!_this3.focusTrap && props.trapFocus) {
      _this3.focusTrap = (0, _focusTrap2.default)(_this3.bodyElement, {
        escapeDeactivates: props.escapeCloses,
        clickOutsideDeactivates: props.clickOutsideCloses,
        returnFocusOnDeactivate: false,
        initialFocus: props.getInitialFocus ? props.getInitialFocus() : undefined,
        fallbackFocus: _this3.bodyElement
      });
      _this3.focusTrap.activate();
      return;
    }

    if (!_this3.hasReceivedFocus && props.receiveFocus) {
      _this3.hasReceivedFocus = true;
      var initialFocusNode = void 0;
      if (props.getInitialFocus) {
        initialFocusNode = props.getInitialFocus();
      } else {
        var tabbableNodes = (0, _tabbable2.default)(_this3.bodyElement, {
          includeContainer: true
        });
        initialFocusNode = tabbableNodes[0];
      }
      if (initialFocusNode && initialFocusNode.focus) {
        initialFocusNode.focus();
      }
    }
  };

  this.onDocumentMousedown = function (event) {
    var onExit = _this3.props.onExit;

    if (!_this3.bodyElement || !onExit) return;
    if (_this3.bodyElement.contains(event.target)) return;
    if (_this3.elementIsWithinChildPopover(event.target)) return;
    if (event.button === 2) return; // Ignore right-click mouse operation
    if ((0, _querySelectorContainsNode2.default)('[data-popover-ignore-clicks]', event.target)) return;
    if (_this3.props.ignoreClickWithinElement && _this3.props.ignoreClickWithinElement(event.target)) {
      return;
    }
    onExit();
  };

  this.onBodyKeyDown = function (event) {
    if (_this3.props.onExit && _this3.props.escapeCloses && event.key === 'Escape') {
      _this3.props.onExit();
    }
  };

  this.onBodyFocus = function () {
    if (!_this3.bodyElement) return;
    if (_this3.focusTrap) {
      _this3.focusTrap.unpause();
    }
  };

  this.elementIsWithinChildPopover = function (element) {
    var elementPopoverId = element.getAttribute('data-popover-id');
    if (elementPopoverId) {
      return Number(elementPopoverId) > _this3.popoverId;
    } else if (element.parentElement && element.parentElement !== document) {
      return _this3.elementIsWithinChildPopover(element.parentElement);
    }
    return false;
  };

  this.setPopoverElement = function (element) {
    _this3.bodyElement = element;
    if (_this3.props.onElement) _this3.props.onElement(element);
  };
};

exports.default = Popover;


Popover.propTypes = {
  /**
   * A function that returns the DOM node to which this Popover should be
   * anchored. `placement` and `alignment` values are related to this anchor.
   */
  getAnchorElement: _propTypes2.default.func.isRequired,
  /**
   * The content of the popover.
   */
  children: _propTypes2.default.node.isRequired,
  /**
   * Preferred placement of the popover in relation to the anchor.
   * Adjusted according to available space.
   */
  placement: _propTypes2.default.oneOf(['top', 'bottom', 'left', 'right']),
  /**
   * Alignment of the popover relative to the side of the anchor on which
   * it's placed. If `placement` is `left` or `right`, meaningful `alignment`
   * values are `top`, `bottom`, and `center`. If `placement` is `top` or
   * `bottom`, meaningful `alignment` values are `left`, `right`, and `center`.
   * Adjusted according to available space.
   */
  alignment: _propTypes2.default.oneOf(['top', 'bottom', 'left', 'right', 'center']),
  /**
   * `'light'`, `'dark'`, or `'warning'`.
   */
  coloring: _propTypes2.default.oneOf(['light', 'dark', 'warning']),
  /**
   * `'medium'`, `'small'`, or `'none'`.
   */
  padding: _propTypes2.default.oneOf(['medium', 'small', 'none']),
  /**
   * Whether or not the popover has a triangle pointer.
   */
  hasPointer: _propTypes2.default.bool,
  /**
   * If `true`, the popover will hide when its anchor is scrolled offscreen.
   * By default, the popover will follow its anchor wherever it goes.
   *
   * If your anchor is within an  internally scrolling area, you may want to
   * use `true`, so the popover doesn't existing in a disembodied state after
   * its anchor is scrolled away.
   */
  hideWhenAnchorIsOffscreen: _propTypes2.default.bool,
  /**
   * If `false`, the popover is *not* allowed to change axes on the anchor when
   * modifying its position to fit available space. By default, popovers on the
   * `left` and `right`, for example, might change to `bottom` is there is
   * neither space on the left nor the right.
   */
  allowPlacementAxisChange: _propTypes2.default.bool,
  /**
   * If `false`, the tooltip is allowed to leave the viewport.
   * By default, it will stick to the edge of the viewport as its anchor
   * scrolls out of sight.
   */
  containWithinViewport: _propTypes2.default.bool,
  /**
   * If `false`, clicking outside the popver will not close it.
   * By default, it does.
   */
  clickOutsideCloses: _propTypes2.default.bool,
  /**
   * If `false`, hitting Escape will not close the popover. By default, it does.
   */
  escapeCloses: _propTypes2.default.bool,
  /**
   * If `true`, the popover will not receive focus when it opens.
   */
  receiveFocus: _propTypes2.default.bool,
  /**
   * If `true`, the popover will receive *and trap* focus when it opens.
   */
  trapFocus: _propTypes2.default.bool,
  /**
   * A function called when popover is dismissed. You need to use this callback
   * to remove the Popover from the rendered page.
   */
  onExit: _propTypes2.default.func,
  /**
   * A function to call as soon as popover element is rendered. Returns the DOM
   * node of the popover body.
   */
  onElement: _propTypes2.default.func,
  /**
   * A function that returns a DOM node. Use to specify which element should
   * receive focus when popover is first rendered.
   */
  getInitialFocus: _propTypes2.default.func,
  /**
   * A function called when an element within the popover is clicked.
   */
  ignoreClickWithinElement: _propTypes2.default.func,
  /**
   * A function that returns a DOM node that should contain the popover within
   * it. The popover's position will be calculated relative to this container,
   * rather than the viewport.
   */
  getContainingElement: _propTypes2.default.func,
  /**
   * Number of pixels by which the popover should be offset from its anchor.
   */
  offsetFromAnchor: _propTypes2.default.number,
  /**
   * Props to pass directly to the `<div>` that will wrap your popover content.
   */
  passthroughProps: _propTypes2.default.object
};

Popover.defaultProps = {
  coloring: 'light',
  placement: 'right',
  alignment: 'top',
  padding: 'medium',
  hasPointer: true,
  hideWhenAnchorIsOffscreen: false,
  allowPlacementAxisChange: true,
  containWithinViewport: true,
  clickOutsideCloses: true,
  escapeCloses: true,
  receiveFocus: true,
  trapFocus: false
};

Popover.repositionPopovers = _popoverPositioner2.default.recalculatePositions;

function noop() {}

function getColors(coloring) {
  if (coloring === 'dark') {
    return {
      background: '#273d56', // gray-dark
      textClass: 'color-white'
    };
  }
  if (coloring === 'warning') {
    return {
      background: '#FFF5A0', // yellow-light
      textClass: 'color-text'
    };
  }
  return {
    background: '#fff',
    textClass: 'color-text'
  };
}