'use strict';

exports.__esModule = true;
exports.default = calculatePointerStyle;

var _prefix = require('prefix');

var _prefix2 = _interopRequireDefault(_prefix);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var PLACEMENT_TOP = 'top';
var PLACEMENT_BOTTOM = 'bottom';
var PLACEMENT_LEFT = 'left';
var PLACEMENT_RIGHT = 'right';
var POINTER_DIRECTION_DOWNWARD = 'downward';
var POINTER_DIRECTION_UPWARD = 'upward';
var POINTER_DIRECTION_LEFTWARD = 'leftward';
var POINTER_DIRECTION_RIGHTWARD = 'rightward';

var mapPlacementToPointerDirection = {};
mapPlacementToPointerDirection[PLACEMENT_TOP] = POINTER_DIRECTION_DOWNWARD;
mapPlacementToPointerDirection[PLACEMENT_BOTTOM] = POINTER_DIRECTION_UPWARD;
mapPlacementToPointerDirection[PLACEMENT_LEFT] = POINTER_DIRECTION_RIGHTWARD;
mapPlacementToPointerDirection[PLACEMENT_RIGHT] = POINTER_DIRECTION_LEFTWARD;

/**
 * @param {string} placement
 * @param {Object} options - See definition in calculatePosition
 * @param {PopoverPositionContext} context - See definition in calculatePositionContext
 * @return {Object}
 */
function calculatePointerStyle(placement, options, context) {
  var _ref4;

  var verticalPointerLeftOffset = Math.round(context.anchorHorizontalCenter - options.pointerBase / 2);
  var horizontalPointerTopOffset = Math.round(context.anchorVerticalCenter - options.pointerBase / 2);
  var helperBorder = options.pointerBase / 2 + 'px solid transparent';
  var coloredBorder = options.pointerAltitude + 'px solid ' + options.pointerColor;
  var pointerDirection = mapPlacementToPointerDirection[placement];
  var prefixedTransform = _prefix2.default.dash('transform');

  if (options.hasPointer === false) {
    return { display: 'none' };
  }

  if (pointerDirection === POINTER_DIRECTION_UPWARD) {
    var _ref;

    return _ref = {}, _ref[prefixedTransform] = 'translate3d(' + verticalPointerLeftOffset + 'px, ' + Math.round(context.anchorAbsoluteTop + context.anchorRect.height + options.offsetFromAnchor - context.documentTopOffset) + 'px, 0)', _ref['border-top'] = 0, _ref['border-bottom'] = coloredBorder, _ref['border-left'] = helperBorder, _ref['border-right'] = helperBorder, _ref;
  }
  if (pointerDirection === POINTER_DIRECTION_DOWNWARD) {
    var _ref2;

    return _ref2 = {}, _ref2[prefixedTransform] = 'translate3d(' + verticalPointerLeftOffset + 'px, ' + Math.round(context.anchorAbsoluteTop - options.offsetFromAnchor - options.pointerAltitude - context.documentTopOffset) + 'px, 0)', _ref2['border-top'] = coloredBorder, _ref2['border-bottom'] = 0, _ref2['border-left'] = helperBorder, _ref2['border-right'] = helperBorder, _ref2;
  }
  if (pointerDirection === POINTER_DIRECTION_LEFTWARD) {
    var _ref3;

    return _ref3 = {}, _ref3[prefixedTransform] = 'translate3d(' + Math.round(context.anchorRect.right + options.offsetFromAnchor) + 'px, ' + (horizontalPointerTopOffset - context.documentTopOffset) + 'px, 0)', _ref3['border-top'] = helperBorder, _ref3['border-bottom'] = helperBorder, _ref3['border-left'] = 0, _ref3['border-right'] = coloredBorder, _ref3;
  }
  return _ref4 = {}, _ref4[prefixedTransform] = 'translate3d(' + Math.round(context.anchorRect.left - options.offsetFromAnchor - options.pointerAltitude) + 'px, ' + (horizontalPointerTopOffset - context.documentTopOffset) + 'px, 0)', _ref4['border-top'] = helperBorder, _ref4['border-bottom'] = helperBorder, _ref4['border-left'] = coloredBorder, _ref4['border-right'] = 0, _ref4;
}