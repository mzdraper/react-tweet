'use strict';

exports.__esModule = true;

var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames = require('classnames');

var _classnames2 = _interopRequireDefault(_classnames);

var _hoverintent = require('hoverintent');

var _hoverintent2 = _interopRequireDefault(_hoverintent);

var _popover = require('../popover');

var _popover2 = _interopRequireDefault(_popover);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var TRIGGER_HOVER = 'hover';
var TRIGGER_FOCUS = 'focus';
var TRIGGER_CLICK = 'click';

/**
 * A smart trigger for managing the state of a [Popover](#popover).
 *
 * If you want to manage the open-closed state of the Popover yourself,
 * use [Popover](#popover) directly.
 *
 * `respondsToClick`, `respondsToHover`, and `respondsToFocus` props determine
 * the means of opening and closing the Popover with interactions. If you open
 * the Popover with a hover or focus, you can also close it by hovering away or
 * blurring. If, however, you open the Popover with a click, you can only close
 * it with another click, on the trigger or outside the Popover. If you
 * open the Popover with a hover and *then* you click, this is equivalent to
 * opening it with a click directly, so it will only close with another
 * click (not from just hovering away).
 */

var PopoverTrigger = function (_React$Component) {
  (0, _inherits3.default)(PopoverTrigger, _React$Component);

  function PopoverTrigger() {
    var _temp, _this, _ret;

    (0, _classCallCheck3.default)(this, PopoverTrigger);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = (0, _possibleConstructorReturn3.default)(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.state = {
      visible: false,
      activeTriggerType: null
    }, _this.openPopover = function (trigger, callback) {
      var alreadyOpen = !!_this.state.visible;
      _this.setState({
        visible: true,
        activeTriggerType: trigger
      }, function () {
        if (!alreadyOpen && _this.props.onPopoverOpen) {
          _this.props.onPopoverOpen();
        }
        if (callback) callback();
      });
    }, _this.closePopover = function (callback) {
      var alreadyClosed = !_this.state.visible;
      _this.setState({
        visible: false,
        activeTriggerType: null
      }, function () {
        if (!alreadyClosed && _this.props.onPopoverClose) {
          _this.props.onPopoverClose();
        }
        if (callback) callback();
      });
    }, _this.onAnyClick = function (event) {
      // If the trigger responds to focus but not click and you *first*
      // focus *then* click, that click closes the popover instead of
      // leaving it open even when the mouse moves away.
      if (!_this.props.respondsToClick && _this.state.visible && _this.state.activeTriggerType === TRIGGER_FOCUS) {
        _this.hide();
        return;
      }

      if (!_this.hoverIsBlocked && (_this.props.disabled || !_this.props.respondsToClick)) {
        return;
      }

      // A trigger click always takes precedence over hover or focus interactions.
      // If the popover is already open by hover or focus, a click will change its
      // priorities, so it stays open even if you mouseleave or blur
      if (_this.state.visible && _this.state.activeTriggerType === TRIGGER_CLICK && (!_this.popoverElement || !_this.popoverElement.contains(event.target))) {
        _this.hide();
      } else {
        _this.showBecauseClick();
      }
    }, _this.blockHover = function () {
      if (!_this.hoverIsBlocked) {
        _this.hoverIsBlocked = true;
        _this.addMouseMoveUnblockTimeout = setTimeout(function () {
          document.addEventListener('mousemove', _this.unblockHover);
        }, 100);
      }
    }, _this.unblockHover = function () {
      if (_this.hoverIsBlocked) {
        _this.hoverIsBlocked = false;
        document.removeEventListener('mousemove', _this.unblockHover);
      }
    }, _this.onTriggerMouseEnter = function () {
      if (_this.props.disabled || !_this.props.respondsToHover || _this.state.activeTriggerType && _this.state.activeTriggerType !== TRIGGER_HOVER || _this.hoverIsBlocked) {
        return;
      }

      _this.showBecauseHover();
    }, _this.onTriggerMouseLeave = function (event) {
      if (_this.props.disabled || !_this.props.respondsToHover || _this.state.activeTriggerType !== TRIGGER_HOVER || _this.hoverIsBlocked) {
        return;
      }

      // When you hover over the popover, you do not want to disappear from beneath
      // your cursor. This keeps the popover open when your cursor is within it.
      if (!_this.popoverElement || !_this.popoverElement.contains(event.relatedTarget)) {
        _this.hideBecauseHover();
      }
    }, _this.onPopoverMouseLeave = function (event) {
      if (_this.props.disabled || !_this.props.respondsToHover || _this.state.activeTriggerType !== TRIGGER_HOVER || _this.hoverIsBlocked) {
        return;
      }

      if (!_this.triggerElement || !_this.triggerElement.contains(event.relatedTarget)) {
        _this.hideBecauseHover();
      }
    }, _this.onTriggerFocus = function () {
      if (_this.props.disabled || !_this.props.respondsToFocus || _this.state.visible || _this.triggerFocusIsBlocked) {
        return;
      }

      _this.showBecauseTriggerFocus();
    }, _this.onTriggerBlur = function () {
      if (_this.props.disabled || !_this.props.respondsToFocus || !_this.state.visible || _this.state.activeTriggerType !== TRIGGER_FOCUS) {
        return;
      }

      _this.hide();
    }, _this.onTriggerKeyDown = function (event) {
      var escapeCloses = _this.props.popoverProps.escapeCloses;
      if (escapeCloses === false) return;
      if (event.key === 'Escape') {
        _this.hide();
      }
    }, _this.showBecauseClick = function () {
      _this.clearTimeouts();
      _this.removePopoverListeners();
      _this.openPopover(TRIGGER_CLICK);
    }, _this.showBecauseHover = function () {
      _this.openPopover(TRIGGER_HOVER);
    }, _this.showBecauseTriggerFocus = function () {
      _this.clearTimeouts();
      _this.removePopoverListeners();
      _this.openPopover(TRIGGER_FOCUS);
    }, _this.hideBecauseHover = function () {
      _this.hide();
    }, _this.hide = function () {
      if (!_this.state.visible) return;
      _this.clearTimeouts();
      _this.removePopoverListeners();
      _this.closePopover();

      // If focus was inside the popover, after the popover closes focus will
      // return to the trigger. We need to prevent that from re-opening the
      // trigger.
      _this.triggerFocusIsBlocked = true;
      _this.cancelTriggerFocusIsBlockedTimeout = setTimeout(function () {
        _this.triggerFocusIsBlocked = false;
      }, 100);
    }, _this.removePopoverListeners = function () {
      var _this2 = _this,
          popoverElement = _this2.popoverElement;

      if (!popoverElement) return;
      popoverElement.removeEventListener('mouseleave', _this.onPopoverMouseLeave);
    }, _this.ignoreClickWithinElement = function (element) {
      if (_this.triggerElement && _this.triggerElement.contains(element)) return true;
      var ignoreClickWithinElement = _this.props.popoverProps.ignoreClickWithinElement;
      if (ignoreClickWithinElement) {
        return ignoreClickWithinElement(element);
      }
      return false;
    }, _this.getAnchorElement = function () {
      var getAnchorElement = _this.props.popoverProps.getAnchorElement;
      if (getAnchorElement) {
        return getAnchorElement();
      }
      return _this.triggerElement.firstChild;
    }, _this.setTriggerElement = function (element) {
      _this.triggerElement = element;
    }, _this.setPopoverElement = function (element) {
      _this.popoverElement = element;
    }, _this.getPopoverContent = function () {
      var content = _this.props.content;

      if (typeof content === 'function') {
        return content();
      } else {
        return content;
      }
    }, _temp), (0, _possibleConstructorReturn3.default)(_this, _ret);
  }

  PopoverTrigger.prototype.componentDidMount = function componentDidMount() {
    if (!this.triggerElement) return;
    this.triggerElement.addEventListener('touchstart', this.blockHover);
    this.triggerElement.addEventListener('mouseout', this.onTriggerMouseLeave);
    this.hoverListener = (0, _hoverintent2.default)(this.triggerElement, this.onTriggerMouseEnter, function () {});
  };

  PopoverTrigger.prototype.componentDidUpdate = function componentDidUpdate(prevProps, prevState) {
    var popoverElement = this.popoverElement;

    var justOpened = prevState.visible === false && this.state.visible === true;

    if (justOpened && popoverElement &&
    // If the popover was opened by hover, pay attention to hovering
    // within the popover itself
    this.state.activeTriggerType === TRIGGER_HOVER) {
      popoverElement.addEventListener('mouseleave', this.onPopoverMouseLeave);
    }

    if (!prevProps.disabled && this.props.disabled) {
      this.hide();
    }
  };

  PopoverTrigger.prototype.componentWillUnmount = function componentWillUnmount() {
    this.hoverListener.remove();
    this.triggerElement.removeEventListener('touchstart', this.blockHover);
    document.removeEventListener('mousemove', this.unblockHover);
    this.clearTimeouts();
  };

  // We need to prevent a touch-tap on the trigger from triggering the hover
  // interaction. So if you touchstart, we immediately block responses to hover
  // interactions; then after a short delay (to allow the event to flush?), we
  // re-allow hover interactions —— in case you're a crazy person and switch
  // from a touchscreen to a mouse.


  // Hover and focus interactions do not overlap: if the popover opened because
  // of a hover (and no clicking), it will only close when you mouseleave;
  // and if it opened because of a focus (and no clicking), it will only close
  // when you blur.

  // This can override a popover-hover trigger type because you might mouseleave
  // the popover onto the trigger


  PopoverTrigger.prototype.clearTimeouts = function clearTimeouts() {
    if (this.cancelTriggerFocusIsBlockedTimeout) clearTimeout(this.cancelTriggerFocusIsBlockedTimeout);
    if (this.addMouseMoveUnblockTimeout) clearTimeout(this.addMouseMoveUnblockTimeout);
  };

  PopoverTrigger.prototype.render = function render() {
    var props = this.props,
        state = this.state;


    var popover = null;
    if (state.visible) {
      // Only send focus inside if we've clicked to open
      var receiveFocus = props.receiveFocus && state.activeTriggerType === TRIGGER_CLICK;
      var trapFocus = props.trapFocus && state.activeTriggerType === TRIGGER_CLICK;

      popover = _react2.default.createElement(
        _popover2.default,
        (0, _extends3.default)({
          onExit: this.hide
        }, props.popoverProps, {
          getAnchorElement: this.getAnchorElement,
          ignoreClickWithinElement: this.ignoreClickWithinElement,
          receiveFocus: receiveFocus,
          trapFocus: trapFocus,
          onElement: this.setPopoverElement
        }),
        this.getPopoverContent()
      );
    }

    // Tooltips need to the popover content to be present in the DOM
    // with the appropriate id, so aria-labelledby will work
    var hiddenContent = null;
    if (!state.visible && props.renderHiddenContent) {
      hiddenContent = _react2.default.createElement(
        'div',
        (0, _extends3.default)({
          className: 'hide-visually'
        }, this.props.popoverProps.passthroughProps || {}),
        this.getPopoverContent()
      );
    }

    var classes = (0, _classnames2.default)({
      block: props.block,
      'inline-block': !props.block
    });

    return _react2.default.createElement(
      'div',
      (0, _extends3.default)({
        ref: this.setTriggerElement,
        className: classes
      }, props.passthroughTriggerProps, {
        onClick: this.onAnyClick,
        onFocus: this.onTriggerFocus,
        onBlur: this.onTriggerBlur,
        onKeyDown: this.onTriggerKeyDown
      }),
      props.children,
      hiddenContent,
      popover
    );
  };

  return PopoverTrigger;
}(_react2.default.Component);

exports.default = PopoverTrigger;


PopoverTrigger.propTypes = {
  /**
   * The trigger content. This can either be a string or valid JSX.
   */
  children: _propTypes2.default.node.isRequired,
  /**
   * If `true`, the element will be `block` displayed instead of `inline-block`.
   *
   * This is sometimes necessary to get your pixel-perfect layout.
   */
  block: _propTypes2.default.bool,
  /**
   * The popover content. This can either be a string, valid JSX, or a function
   * returning either.
   */
  content: _propTypes2.default.oneOfType([_propTypes2.default.func, _propTypes2.default.node]),
  /**
   * **You will not need to use this.** This prop is used by
   * [Tooltip](#tooltip) for improved accessbility.
   *
   * If `true`, the popover will always be rendered *but it will be visually
   * hidden when inactive*.
   *
   * By default, the popover is added to and removed from the DOM dynamically.
   */
  renderHiddenContent: _propTypes2.default.bool,
  /**
   * Whether or not the popover receives focus when it opens.
   *
   * This will *only* happen if the trigger is opened with a click.
   */
  receiveFocus: _propTypes2.default.bool,
  /**
   * Whether or not the popover receives *and traps* focus when it opens.
   *
   * This will *only* happen if the trigger is opened with a click.
   */
  trapFocus: _propTypes2.default.bool,
  /**
   * Whether or not the trigger responds to clicks.
   *
   * **Warning**: You probably don't want to use `respondsToClick` and
   * `receivesFocus` *and* `respondsToFocus` all together, because they can
   * have clashing interactions. For example, when the popover that trapped
   * focus closes, it returns focus to the trigger, which then causes the
   * popover to open again.
   */
  respondsToClick: _propTypes2.default.bool,
  /**
   * Whether or not the trigger responds to `mouseenter` and `mouseleave` events.
   */
  respondsToHover: _propTypes2.default.bool,
  /**
   * Whether or not the trigger responds to `focus` and `blur` events.
   */
  respondsToFocus: _propTypes2.default.bool,
  /**
   * Whether or not the trigger is disabled.
   */
  disabled: _propTypes2.default.bool,
  /**
   * Props to pass directly to the [Popover](#popover) component. See Popover's
   * documentation for details.
   */
  popoverProps: _propTypes2.default.object,
  /**
   * Props to pass directly to the `<div>` that will wrap your trigger content.
   */
  passthroughTriggerProps: _propTypes2.default.object,
  /**
   * Callback that is invoked when the popover opens.
   */
  onPopoverOpen: _propTypes2.default.func,
  /**
   * Callback that is invoked when the popover closes.
   */
  onPopoverClose: _propTypes2.default.func
};

PopoverTrigger.defaultProps = {
  block: false,
  disabled: false,
  renderHiddenContent: false,
  receiveFocus: true,
  trapFocus: false,
  respondsToClick: true,
  respondsToHover: false,
  respondsToFocus: false,
  popoverProps: {}
};