'use strict';

const addDeployEnv = require('../add-deploy-env');
const getDeployEnv = require('../util/get-deploy-env');

jest.mock('../util/get-deploy-env', () => jest.fn());

jest.mock(
  'webpack',
  () => {
    const DefinePlugin = jest.fn().mockImplementation(x => x);
    return { DefinePlugin };
  },
  { virtual: true }
);
const webpack = require('webpack');

describe('addDeployEnv', () => {
  beforeEach(() => {
    getDeployEnv.mockReturnValue('staging');
  });

  test('works without existing webpackPlugins', () => {
    const config = {};
    const result = addDeployEnv(config);
    expect(webpack.DefinePlugin).toHaveBeenCalledWith({
      'process.env.DEPLOY_ENV': '"staging"'
    });
    expect(result.webpackPlugins).toEqual([
      { 'process.env.DEPLOY_ENV': '"staging"' }
    ]);
  });

  test('uses return value from getDeployEnv', () => {
    getDeployEnv.mockReturnValue('production');
    const config = {};
    const result = addDeployEnv(config);
    expect(webpack.DefinePlugin).toHaveBeenCalledWith({
      'process.env.DEPLOY_ENV': '"production"'
    });
    expect(result.webpackPlugins).toEqual([
      { 'process.env.DEPLOY_ENV': '"production"' }
    ]);
  });

  test('works with existing webpackPlugins', () => {
    const config = {
      webpackPlugins: [{ foo: 'bar' }, { baz: 1 }]
    };
    const result = addDeployEnv(config);
    expect(webpack.DefinePlugin).toHaveBeenCalledWith({
      'process.env.DEPLOY_ENV': '"staging"'
    });
    expect(result.webpackPlugins).toEqual([
      { foo: 'bar' },
      { baz: 1 },
      { 'process.env.DEPLOY_ENV': '"staging"' }
    ]);
  });

  test('returns a new object', () => {
    const config = {};
    const result = addDeployEnv(config);
    expect(result).not.toBe(config);
  });
});
